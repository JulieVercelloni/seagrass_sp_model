---
title: "Seagrass spatio-temporal modelling"
subtitle: "Eastern Banks in the Moreton Bay"
author:
  - name: Julie Vercelloni
    corresponding: true
    email: j.vercelloni@aims.gov.au
  - name: Nicholas Hammerman
engine: knitr
format:
  html:
   # toc: true
  #  toc-location: left
    title-block-banner: true
    toc-depth: 3
    highlight-style: atom-one
    embed-resources: true
    theme:
      light: flatly
      dark: darkly
    code-overflow: wrap
    code-fold: true
    number-sections: true
    number-depth: 2
    shift-heading-level-by: -1
    crossref:
      lst-title: Code listing
    fig-align: center
    text-align: center
    acm-html: default
# css: styles.css
execute: 
  message: false
  warning: false
  cache: true
editor:
  markdown:
    wrap: 72
---

```{r, chunkOpts, echo = FALSE}
knitr::opts_chunk$set(cache = TRUE)
#knitr::opts_knit$set(root.dir = "..")
```
```{r}
#| include: true
#| echo: false
#| eval: true

rm(list=ls())

# Source packages and functions 
path <- "../"
source(paste0(path,"R/packages.R"))
source(paste0(path,"R/functions.R"))

# Assign figure path
assign("FIGURES_PATH", paste0(path,"figures/"), envir = .GlobalEnv)
```

### Exploratory Data Analysis {.unnumbered}

```{r}
#| include: true
#| echo: true
#| eval: true

# Read the data 
dat <- read.csv(paste0(path,"data/compiled_cleaned_data_long.csv"))
# Get duplicated rows 
dat_dup <- slice_duplicates(dat)
# If image duplicates, keep only one 
dat <- clean_data(dat)

```

::: {.callout-warning}
**`r nrow(dat_dup)` images in the original dataset are duplicated. A unique version of duplicated images are kept in the analysis.**  
:::

#### Temporal dimension 

The dataset includes `r length(sort(unique(dat$year)))` years of observations. 

```{r}
#| echo: false
#| eval: true
date_unique <- dat |> 
  group_by(date) |>
  filter(row_number() == 1)

date_unique$date <- as.Date(date_unique$date)
years <- format(date_unique$date, "%Y")
year_counts <- table(years)
```

```{r}
#| label: tbl-mod
#| eval: true
#| echo: false
#| tbl-cap: Number of surveys per year. 
knitr::kable(year_counts)
```

<!-- ```{r}
#| echo: false
#| eval: true

green_palette <- c(
  "#e9f7e5", "#c8e8c1", "#a6d89d", "#84d079", "#62c755", # Light to medium greens
  "#41b530", "#2ea50a", "#116c00", "#0f5700",  # Darker greens
  "#f0e4d7", "#e2d4b7", "#c8b99a", "#b29e7f", "#9a8563"   # Beige tones
)

#ggplot(dat |> filter(!str_starts(category_name, "total")) |>
#    filter(!category_name == ""), aes(x = value, fill = category_name)) + 
#geom_density(alpha = .6) +
#facet_wrap(~category_name, scales = "free", ncol = 3) +
#  scale_fill_manual(values = green_palette) +
#theme_bw() +
#theme(strip.text = element_blank())


#ggplot(dat |> filter(str_starts(category_name, "total")) |>
#    filter(!category_name == ""), aes(x = value, fill = category_name)) + 
#geom_density(alpha = .6) +
#facet_wrap(~category_name, scales = "free") +
#  scale_fill_manual(values = green_palette[1:9]) +
#theme_bw() +
#theme(strip.text = element_blank())

# make dataset to look at the proportion of total seagrass per images per year and bank 

``` -->

::: {.callout-important}

```{r}
#| include: true
#| echo: false
#| eval: true
dat_issue <- dat |>
 filter(value > total) 
 
 dat_issue_tal <- dat_issue |>
 group_by(category_name) |>
 count()
```
**`r nrow(dat_issue)` images have more than 50 classifications per image. @fig-issue displays associated labels with excessing number of classification.**    

```{r}
#| label: fig-issue
#| eval: true
#| echo: false
#| fig-cap: Labels with more than 50 classifications per image. 
ggplot(dat_issue_tal, aes(x = reorder(category_name, -n), y = n)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(x = "Label", y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```
:::

::: {.callout-important}

```{r}
#| include: true
#| echo: true
#| eval: true
missing_coord <- dat |>
  group_by(image_name) |>
  filter(row_number() == 1) |> 
  filter(is.na(Longitude) | is.na(Latitude)) 
  
missing_coord_tal <- missing_coord  |>
  group_by(image_name) |>
  filter(row_number() == 1) |>
  group_by(year) |>
  count()
```

**`r nrow(missing_coord)` images are recorded without coordinates. @tbl-miss shows that most of these images were taken in 2011.** 

```{r}
#| label: tbl-miss
#| echo: false
#| eval: true
#| tbl-cap: Number of missing coordinates per year.
kable(missing_coord_tal)
```
:::



#### List of labels
```{r}
#| echo: true
#| eval: true
unique(dat$category_name)
```

#### List of eastern banks (code)

```{r}
#| echo: true
#| eval: true
unique(dat$bank)
```

### Interactive map {.unnumbered} 

```{r}
#| echo: false
#| eval: true
dat_plot <- dat |> 
  filter(!is.na(Longitude) | !is.na(Latitude)) |>
  group_by(image_name) |>
  filter(row_number() == 1)
```

```{r}
#| echo: true
#| eval: true
my_colors <- colorRampPalette(wes_palette("AsteroidCity1", 5, type = "discrete"))(length(unique(dat_plot$year)))
pal <- colorFactor(my_colors, domain = dat_plot$year)

map_year <-  leaflet(option=leafletOptions(zoomControl = FALSE))%>% 
  addProviderTiles("Esri.WorldStreetMap", group = "Streetmap") %>% 
  addProviderTiles("Esri.WorldImagery", group = "terrain") %>%
  addCircleMarkers(data=dat_plot,lng = ~Longitude, lat = ~Latitude, 
                   popup = ~date, radius=5,
                   stroke = FALSE, fillOpacity = 0.8,
                   color = ~pal(year)) %>% 
  addLegend(data=dat_plot,position = "topright", pal = pal, 
            values = ~dat_plot$year,
            title = "Year",
            opacity = .9) %>%
  addMiniMap(position = "topleft", width = 170,
             height = 150) 

saveWidget(map_year, file= paste0(FIGURES_PATH,"data_location.html"))
```
See **data_location.html** in the figure folder. 

### Data clustering {.unnumbered} 

A hierarchical clustering analysis was performed to identify areas of interest where images from different surveyed years overlap. Different aggregation distances were tested to determine the optimal reef area, balancing ecological relevance and the number of images per year.


```{r}
#| echo: false
#| eval: true

dat_cut <- dat |>
  group_by(image_name) |>
  filter(row_number() == 1) |>
  dplyr::select(-category_name) |> 
  filter(!is.na(Longitude) | !is.na(Latitude)) |>
  data.frame()

# transform in utm coordinates 
dat_full_utm <- dat_cut %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = st_crs(4326)) %>%
  st_transform(crs = "+proj=utm +zone=56 +south +datum=WGS84") %>%
  dplyr::select(year, transect, image_name) %>%
  mutate(UTMX = st_coordinates(.)[,1],
         UTMY  = st_coordinates(.)[,2]) %>%
  st_drop_geometry() %>%
  dplyr::arrange(transect)

tree_loc <- dat_full_utm %>%
  dplyr::select(transect, UTMX, UTMY) %>%
  split(.$transect) 

# Clustering
clust_list <-
  tree_loc %>%
  map(.f = function(x){
    dist(x[,c("UTMX","UTMY")])
  }) %>%
  map(.f=hclust)

s_split <- unique(dat_full_utm$transect)

cut.tree.list <- vector("list", length(s_split))

for (i in 1:length(s_split)){
  cut.tree.list[[i]] <-   filter(dat_full_utm, transect == s_split[i] ) %>%
     mutate("10" = cutree( clust_list[[i]], h=5)) %>%
    mutate("50" = cutree( clust_list[[i]], h=25)) %>%
    mutate("70" = cutree( clust_list[[i]], h=35)) %>%
    mutate("100" = cutree( clust_list[[i]], h=50)) %>%
    mutate("150" = cutree( clust_list[[i]], h=75)) %>%
    mutate("200" = cutree( clust_list[[i]], h=100)) %>%
    mutate("300" = cutree( clust_list[[i]], h=150)) %>%
    gather(key = aggregation_distance, value = group,
           6:12)
}

# Make table
cut.tree.collapsed <- do.call(what = rbind, args = cut.tree.list) %>%
  mutate(splitting.var = interaction(transect, aggregation_distance, group, drop=T)) 

## Keep groups with more than 3 images per year per group 

dat_clean1 <-cut.tree.collapsed |> 
  group_by(splitting.var,year) |> 
  nest() |>
  mutate(m = map(data, function(d) nrow(d))) |>
  filter(!m<3)%>%dplyr::select(year,splitting.var) |> 
  inner_join(cut.tree.collapsed) |>
  dplyr::arrange(aggregation_distance,group) |>
  data.frame()

## At least 2 replicate through time
dat_clean <- dat_clean1 |>
  group_by(splitting.var) |> 
  mutate(m2=length(unique(year))) |> 
  filter(!m2<3) |>
  dplyr::select(splitting.var) |>
  distinct() |>
  inner_join(dat_clean1) |>
  dplyr::arrange(aggregation_distance,group) |>
  data.frame() |>
  droplevels()

dat_tally <- dat_clean |> group_by(splitting.var, year) |> tally()
wrong_group <- names(which(table(dat_tally$splitting.var)<=1)) # this should be empty 
```

```{r}
#| echo: false
#| eval: true
#| cache: false 

# Summarize 

# Number of images per aggregation distance and year 
# dat_clean_tal <- dat_clean |>
#   group_by(splitting.var, year) |>
#   filter(row_number()==1) |>
#   ungroup() |>
#   group_by(aggregation_distance, year) |>
#   tally() |>
#   mutate(aggregation_distance = factor(aggregation_distance, levels = c("10", "50", "70", "100", "150","200", "300")))|>
#   dplyr::arrange(aggregation_distance)

dat_clean$aggregation_distance <- as.factor(dat_clean$aggregation_distance)

dat_clean_tal <- dat_clean |> 
  group_by(splitting.var,year, aggregation_distance) |> 
  nest() |>
  dplyr::select(-data) |>
  group_by(year, aggregation_distance) |>
  tally() |>
 mutate(aggregation_distance = factor(aggregation_distance, levels = c("10", "50", "70", "100", "150","200", "300"))) |>
 dplyr::arrange(aggregation_distance)

my_colors <- colorRampPalette(wes_palette("GrandBudapest2", 4, type = "discrete"))(length(unique(dat_clean_tal$aggregation_distance)))

p11 <- ggplot(dat_clean_tal, aes(x = as.factor(year), y = n, fill =    aggregation_distance)) + 
  geom_bar(stat = "identity", position = position_dodge(width = .8), alpha = .7, col = "black") + 
  theme_bw() + ylab("Number of sub-transects")  + 
  xlab("year") +
  theme(legend.position = "bottom",
        strip.background =element_rect(fill="gray95")) +
  scale_fill_manual("Aggregation distance", values  = my_colors)

# Number of replicated year per aggregation_distance 

dat_clean_tal2 <- dat_clean |>
  group_by(splitting.var, year, aggregation_distance) |>
  tally() |>
  ungroup() |>
  dplyr::select(-n) |>
  group_by(splitting.var, aggregation_distance) |>
  tally() |>
 mutate(aggregation_distance = factor(aggregation_distance, levels = c("10", "50", "70", "100", "150","200", "300"))) |>
 dplyr::arrange(aggregation_distance)

p2 <- ggplot(dat_clean_tal2, aes(x= aggregation_distance, y = n, fill = aggregation_distance)) + geom_boxplot() + 
  theme_bw() + ylab("Number of replicated years")  + 
  xlab("") +
  theme(legend.position = "none",
        strip.background =element_rect(fill="gray95"),
        axis.text.x = element_blank()) +
  scale_fill_manual("Aggregation distance", values  = my_colors)

# Number of sub-sites per aggregation_distance

dat_clean_tal3 <- dat_clean |> 
  group_by(splitting.var, aggregation_distance) |> 
  nest() |>
  dplyr::select(-data) |>
  group_by(aggregation_distance) |>
  tally() |>
 mutate(aggregation_distance = factor(aggregation_distance, levels = c("10", "50", "70", "100", "150","200", "300"))) |>
 dplyr::arrange(aggregation_distance)


p3 <- ggplot(dat_clean_tal3, aes(x= aggregation_distance, y = n, fill = aggregation_distance)) + geom_bar(stat = "identity", col = "black") + 
  theme_bw() + ylab("Number of sub-transects")  + 
  xlab("") +
  theme(legend.position = "none",
        strip.background =element_rect(fill="gray95"),
        axis.text.x = element_blank()) +
  scale_fill_manual("Aggregation distance", values  = my_colors)

pfig <- (p3 | p2) / p11 + plot_annotation(tag_levels = 'A')
```

```{r, fig.height = 8, fig.width = 7}
#| label: fig-clust
#| eval: true
#| echo: false
#| fig-cap: Results from the hierarchical clustering. 
pfig
```

::: {.callout-tip}
The aggregation distance of XXX meters results in a good balance between spatial (number of sub-transect) and temporal (number of replicated years) resolution (@fig-clust A & B). 
:::